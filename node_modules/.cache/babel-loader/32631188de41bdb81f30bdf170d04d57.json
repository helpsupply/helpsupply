{"ast":null,"code":"/*\n * extsprintf.js: extended POSIX-style sprintf\n */\nvar mod_assert = require('assert');\n\nvar mod_util = require('util');\n/*\n * Public interface\n */\n\n\nexports.sprintf = jsSprintf;\nexports.printf = jsPrintf;\nexports.fprintf = jsFprintf;\n/*\n * Stripped down version of s[n]printf(3c).  We make a best effort to throw an\n * exception when given a format string we don't understand, rather than\n * ignoring it, so that we won't break existing programs if/when we go implement\n * the rest of this.\n *\n * This implementation currently supports specifying\n *\t- field alignment ('-' flag),\n * \t- zero-pad ('0' flag)\n *\t- always show numeric sign ('+' flag),\n *\t- field width\n *\t- conversions for strings, decimal integers, and floats (numbers).\n *\t- argument size specifiers.  These are all accepted but ignored, since\n *\t  Javascript has no notion of the physical size of an argument.\n *\n * Everything else is currently unsupported, most notably precision, unsigned\n * numbers, non-decimal numbers, and characters.\n */\n\nfunction jsSprintf(ofmt) {\n  var regex = ['([^%]*)',\n  /* normal text */\n  '%',\n  /* start of format */\n  '([\\'\\\\-+ #0]*?)',\n  /* flags (optional) */\n  '([1-9]\\\\d*)?',\n  /* width (optional) */\n  '(\\\\.([1-9]\\\\d*))?',\n  /* precision (optional) */\n  '[lhjztL]*?',\n  /* length mods (ignored) */\n  '([diouxXfFeEgGaAcCsSp%jr])'\n  /* conversion */\n  ].join('');\n  var re = new RegExp(regex);\n  /* variadic arguments used to fill in conversion specifiers */\n\n  var args = Array.prototype.slice.call(arguments, 1);\n  /* remaining format string */\n\n  var fmt = ofmt;\n  /* components of the current conversion specifier */\n\n  var flags, width, precision, conversion;\n  var left, pad, sign, arg, match;\n  /* return value */\n\n  var ret = '';\n  /* current variadic argument (1-based) */\n\n  var argn = 1;\n  /* 0-based position in the format string that we've read */\n\n  var posn = 0;\n  /* 1-based position in the format string of the current conversion */\n\n  var convposn;\n  /* current conversion specifier */\n\n  var curconv;\n  mod_assert.equal('string', typeof fmt, 'first argument must be a format string');\n\n  while ((match = re.exec(fmt)) !== null) {\n    ret += match[1];\n    fmt = fmt.substring(match[0].length);\n    /*\n     * Update flags related to the current conversion specifier's\n     * position so that we can report clear error messages.\n     */\n\n    curconv = match[0].substring(match[1].length);\n    convposn = posn + match[1].length + 1;\n    posn += match[0].length;\n    flags = match[2] || '';\n    width = match[3] || 0;\n    precision = match[4] || '';\n    conversion = match[6];\n    left = false;\n    sign = false;\n    pad = ' ';\n\n    if (conversion == '%') {\n      ret += '%';\n      continue;\n    }\n\n    if (args.length === 0) {\n      throw jsError(ofmt, convposn, curconv, 'has no matching argument ' + '(too few arguments passed)');\n    }\n\n    arg = args.shift();\n    argn++;\n\n    if (flags.match(/[\\' #]/)) {\n      throw jsError(ofmt, convposn, curconv, 'uses unsupported flags');\n    }\n\n    if (precision.length > 0) {\n      throw jsError(ofmt, convposn, curconv, 'uses non-zero precision (not supported)');\n    }\n\n    if (flags.match(/-/)) left = true;\n    if (flags.match(/0/)) pad = '0';\n    if (flags.match(/\\+/)) sign = true;\n\n    switch (conversion) {\n      case 's':\n        if (arg === undefined || arg === null) {\n          throw jsError(ofmt, convposn, curconv, 'attempted to print undefined or null ' + 'as a string (argument ' + argn + ' to ' + 'sprintf)');\n        }\n\n        ret += doPad(pad, width, left, arg.toString());\n        break;\n\n      case 'd':\n        arg = Math.floor(arg);\n\n      /*jsl:fallthru*/\n\n      case 'f':\n        sign = sign && arg > 0 ? '+' : '';\n        ret += sign + doPad(pad, width, left, arg.toString());\n        break;\n\n      case 'x':\n        ret += doPad(pad, width, left, arg.toString(16));\n        break;\n\n      case 'j':\n        /* non-standard */\n        if (width === 0) width = 10;\n        ret += mod_util.inspect(arg, false, width);\n        break;\n\n      case 'r':\n        /* non-standard */\n        ret += dumpException(arg);\n        break;\n\n      default:\n        throw jsError(ofmt, convposn, curconv, 'is not supported');\n    }\n  }\n\n  ret += fmt;\n  return ret;\n}\n\nfunction jsError(fmtstr, convposn, curconv, reason) {\n  mod_assert.equal(typeof fmtstr, 'string');\n  mod_assert.equal(typeof curconv, 'string');\n  mod_assert.equal(typeof convposn, 'number');\n  mod_assert.equal(typeof reason, 'string');\n  return new Error('format string \"' + fmtstr + '\": conversion specifier \"' + curconv + '\" at character ' + convposn + ' ' + reason);\n}\n\nfunction jsPrintf() {\n  var args = Array.prototype.slice.call(arguments);\n  args.unshift(process.stdout);\n  jsFprintf.apply(null, args);\n}\n\nfunction jsFprintf(stream) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return stream.write(jsSprintf.apply(this, args));\n}\n\nfunction doPad(chr, width, left, str) {\n  var ret = str;\n\n  while (ret.length < width) {\n    if (left) ret += chr;else ret = chr + ret;\n  }\n\n  return ret;\n}\n/*\n * This function dumps long stack traces for exceptions having a cause() method.\n * See node-verror for an example.\n */\n\n\nfunction dumpException(ex) {\n  var ret;\n  if (!(ex instanceof Error)) throw new Error(jsSprintf('invalid type for %%r: %j', ex));\n  /* Note that V8 prepends \"ex.stack\" with ex.toString(). */\n\n  ret = 'EXCEPTION: ' + ex.constructor.name + ': ' + ex.stack;\n\n  if (ex.cause && typeof ex.cause === 'function') {\n    var cex = ex.cause();\n\n    if (cex) {\n      ret += '\\nCaused by: ' + dumpException(cex);\n    }\n  }\n\n  return ret;\n}","map":{"version":3,"sources":["/Users/johnson/Dropbox/Coronavirus/hc-v2/hospitalcommunity/node_modules/verror/node_modules/extsprintf/lib/extsprintf.js"],"names":["mod_assert","require","mod_util","exports","sprintf","jsSprintf","printf","jsPrintf","fprintf","jsFprintf","ofmt","regex","join","re","RegExp","args","Array","prototype","slice","call","arguments","fmt","flags","width","precision","conversion","left","pad","sign","arg","match","ret","argn","posn","convposn","curconv","equal","exec","substring","length","jsError","shift","undefined","doPad","toString","Math","floor","inspect","dumpException","fmtstr","reason","Error","unshift","process","stdout","apply","stream","write","chr","str","ex","constructor","name","stack","cause","cex"],"mappings":"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","sourcesContent":["/*\n * extsprintf.js: extended POSIX-style sprintf\n */\n\nvar mod_assert = require('assert');\nvar mod_util = require('util');\n\n/*\n * Public interface\n */\nexports.sprintf = jsSprintf;\nexports.printf = jsPrintf;\nexports.fprintf = jsFprintf;\n\n/*\n * Stripped down version of s[n]printf(3c).  We make a best effort to throw an\n * exception when given a format string we don't understand, rather than\n * ignoring it, so that we won't break existing programs if/when we go implement\n * the rest of this.\n *\n * This implementation currently supports specifying\n *\t- field alignment ('-' flag),\n * \t- zero-pad ('0' flag)\n *\t- always show numeric sign ('+' flag),\n *\t- field width\n *\t- conversions for strings, decimal integers, and floats (numbers).\n *\t- argument size specifiers.  These are all accepted but ignored, since\n *\t  Javascript has no notion of the physical size of an argument.\n *\n * Everything else is currently unsupported, most notably precision, unsigned\n * numbers, non-decimal numbers, and characters.\n */\nfunction jsSprintf(ofmt)\n{\n\tvar regex = [\n\t    '([^%]*)',\t\t\t\t/* normal text */\n\t    '%',\t\t\t\t/* start of format */\n\t    '([\\'\\\\-+ #0]*?)',\t\t\t/* flags (optional) */\n\t    '([1-9]\\\\d*)?',\t\t\t/* width (optional) */\n\t    '(\\\\.([1-9]\\\\d*))?',\t\t/* precision (optional) */\n\t    '[lhjztL]*?',\t\t\t/* length mods (ignored) */\n\t    '([diouxXfFeEgGaAcCsSp%jr])'\t/* conversion */\n\t].join('');\n\n\tvar re = new RegExp(regex);\n\n\t/* variadic arguments used to fill in conversion specifiers */\n\tvar args = Array.prototype.slice.call(arguments, 1);\n\t/* remaining format string */\n\tvar fmt = ofmt;\n\n\t/* components of the current conversion specifier */\n\tvar flags, width, precision, conversion;\n\tvar left, pad, sign, arg, match;\n\n\t/* return value */\n\tvar ret = '';\n\n\t/* current variadic argument (1-based) */\n\tvar argn = 1;\n\t/* 0-based position in the format string that we've read */\n\tvar posn = 0;\n\t/* 1-based position in the format string of the current conversion */\n\tvar convposn;\n\t/* current conversion specifier */\n\tvar curconv;\n\n\tmod_assert.equal('string', typeof (fmt),\n\t    'first argument must be a format string');\n\n\twhile ((match = re.exec(fmt)) !== null) {\n\t\tret += match[1];\n\t\tfmt = fmt.substring(match[0].length);\n\n\t\t/*\n\t\t * Update flags related to the current conversion specifier's\n\t\t * position so that we can report clear error messages.\n\t\t */\n\t\tcurconv = match[0].substring(match[1].length);\n\t\tconvposn = posn + match[1].length + 1;\n\t\tposn += match[0].length;\n\n\t\tflags = match[2] || '';\n\t\twidth = match[3] || 0;\n\t\tprecision = match[4] || '';\n\t\tconversion = match[6];\n\t\tleft = false;\n\t\tsign = false;\n\t\tpad = ' ';\n\n\t\tif (conversion == '%') {\n\t\t\tret += '%';\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (args.length === 0) {\n\t\t\tthrow (jsError(ofmt, convposn, curconv,\n\t\t\t    'has no matching argument ' +\n\t\t\t    '(too few arguments passed)'));\n\t\t}\n\n\t\targ = args.shift();\n\t\targn++;\n\n\t\tif (flags.match(/[\\' #]/)) {\n\t\t\tthrow (jsError(ofmt, convposn, curconv,\n\t\t\t    'uses unsupported flags'));\n\t\t}\n\n\t\tif (precision.length > 0) {\n\t\t\tthrow (jsError(ofmt, convposn, curconv,\n\t\t\t    'uses non-zero precision (not supported)'));\n\t\t}\n\n\t\tif (flags.match(/-/))\n\t\t\tleft = true;\n\n\t\tif (flags.match(/0/))\n\t\t\tpad = '0';\n\n\t\tif (flags.match(/\\+/))\n\t\t\tsign = true;\n\n\t\tswitch (conversion) {\n\t\tcase 's':\n\t\t\tif (arg === undefined || arg === null) {\n\t\t\t\tthrow (jsError(ofmt, convposn, curconv,\n\t\t\t\t    'attempted to print undefined or null ' +\n\t\t\t\t    'as a string (argument ' + argn + ' to ' +\n\t\t\t\t    'sprintf)'));\n\t\t\t}\n\t\t\tret += doPad(pad, width, left, arg.toString());\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\targ = Math.floor(arg);\n\t\t\t/*jsl:fallthru*/\n\t\tcase 'f':\n\t\t\tsign = sign && arg > 0 ? '+' : '';\n\t\t\tret += sign + doPad(pad, width, left,\n\t\t\t    arg.toString());\n\t\t\tbreak;\n\n\t\tcase 'x':\n\t\t\tret += doPad(pad, width, left, arg.toString(16));\n\t\t\tbreak;\n\n\t\tcase 'j': /* non-standard */\n\t\t\tif (width === 0)\n\t\t\t\twidth = 10;\n\t\t\tret += mod_util.inspect(arg, false, width);\n\t\t\tbreak;\n\n\t\tcase 'r': /* non-standard */\n\t\t\tret += dumpException(arg);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tthrow (jsError(ofmt, convposn, curconv,\n\t\t\t    'is not supported'));\n\t\t}\n\t}\n\n\tret += fmt;\n\treturn (ret);\n}\n\nfunction jsError(fmtstr, convposn, curconv, reason) {\n\tmod_assert.equal(typeof (fmtstr), 'string');\n\tmod_assert.equal(typeof (curconv), 'string');\n\tmod_assert.equal(typeof (convposn), 'number');\n\tmod_assert.equal(typeof (reason), 'string');\n\treturn (new Error('format string \"' + fmtstr +\n\t    '\": conversion specifier \"' + curconv + '\" at character ' +\n\t    convposn + ' ' + reason));\n}\n\nfunction jsPrintf() {\n\tvar args = Array.prototype.slice.call(arguments);\n\targs.unshift(process.stdout);\n\tjsFprintf.apply(null, args);\n}\n\nfunction jsFprintf(stream) {\n\tvar args = Array.prototype.slice.call(arguments, 1);\n\treturn (stream.write(jsSprintf.apply(this, args)));\n}\n\nfunction doPad(chr, width, left, str)\n{\n\tvar ret = str;\n\n\twhile (ret.length < width) {\n\t\tif (left)\n\t\t\tret += chr;\n\t\telse\n\t\t\tret = chr + ret;\n\t}\n\n\treturn (ret);\n}\n\n/*\n * This function dumps long stack traces for exceptions having a cause() method.\n * See node-verror for an example.\n */\nfunction dumpException(ex)\n{\n\tvar ret;\n\n\tif (!(ex instanceof Error))\n\t\tthrow (new Error(jsSprintf('invalid type for %%r: %j', ex)));\n\n\t/* Note that V8 prepends \"ex.stack\" with ex.toString(). */\n\tret = 'EXCEPTION: ' + ex.constructor.name + ': ' + ex.stack;\n\n\tif (ex.cause && typeof (ex.cause) === 'function') {\n\t\tvar cex = ex.cause();\n\t\tif (cex) {\n\t\t\tret += '\\nCaused by: ' + dumpException(cex);\n\t\t}\n\t}\n\n\treturn (ret);\n}\n"]},"metadata":{},"sourceType":"script"}